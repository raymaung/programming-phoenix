# Chapter 13 - Testing Channels and OTP

* We'll learn how to use the Phoeni helpers to simplify channels testings
* Focus on everything except external HTTP request to WolframAlpha

## Testing the Information System

`info_sys_test.ex`

```
defmodule InfoSysTest do
  use ExUnit.Case

  alias InfoSys.Result

  defmodule TestBackend do
    def start_link(query, ref, owner, limit) do
      Task.start_link(__MODULE__, :fetch, [query, ref, owner, limit])
    end

    def fetch("result", ref, owner, _limit) do
      send(owner, {:results, ref, [%Result{backend: "test", text: "result"}]})
    end

    def fetch("none", ref, owner, _limit) do
      send(owner, {:results, ref, []})
    end
  end

  test "compute/2 with backend results" do
    assert [%Result{backend: "test", text: "result"}] =
            InfoSys.compute("result", backends: [TestBackend])
  end

  test "compute/2 with no backend results" do
    assert [] = InfoSys.compute("none", backends: [TestBackend])
  end
end

```

## Incorporating Timeouts in Our Tests

* Need a way to simulate a backend taking longer than expected
* You might be tempted to write a test using `refute Process.alive?(pid)`
    * ie. In the event of a time out, the Information system calls `Process.exit` to terminate
    * If the exit signal arrives **before** the `refute` call, the test pass;
    * if not the test fails
* You should **rarelly** use `Process.alive?(pid)`
* Instead use `Process.monitor` to deliver a `DOWN` message when the monitored process exits

* Notice `refute_receieved` instead of `refute_receieve` which waits `100ms`
    * we don't expect **any** message to arrive.

    
## Managing Crashes

* We want to make sure the crash is isolated from the caller
* Use `@tag :capture_log` to capture all log messages

    ```
    @tag :capture_log
    test "compute/2 discards backend errors" do
        assert InfoSys.compute("boom", backends: [TestBackend]) == []
        refute_received {:DOWN, _, _, _, _}
        refute_received :timeout
    end
    ```
    * see `ExUnit.CaptureLog` module documentation
    * and its sibling `ExUnit.CaptureIO` is useful for testing logs and I/O

## Isolating Wolfram

* In Elixir, we want to avoid mocking whenever possible.
    * Most mocking libraries - including Dynamic stubbing libraries end up changing global behaviours
    * ie. Replacing a function in the HTTP client library to return some stubbs
        * Since they are **globals**, it affects all coding running at the same time
        * That means tests written in this way can no longer run concurrently
        * and start snowballing  to requiring more and more mocking
    * Better strategy to to identify code that that's difficult to test live
        * build a configurable replaceable testing implementation rather than a dynamic mock

```
@http Application.get_env(:info_sys, :wolfram)[:http_client] || :httpc
defp fetch_xml(query_str) do
  {:ok, {_, _, body}} = @http.request(
    String.to_char_list(
      "http://api.wolframalpha.com/v2/query" <>
      "?appid#{ app_id() }" <>
      "&input=#{ URI.encode_www_form(query_str) }" <>
      "&format=plaintext"
  ))
  body
end
```    

* `@http Application.get_env(:info_sys, :wolfram)[:http_client] || :httpc`
    * first look up an `:http_client` module from the mix config or default to `:httpc`
    * bake the module into an `@http` module attirbute at compile time
    * Replace `:httpc.request` with `@http.request`

    
> **Bypass** `https://github.com/PSPDFKit-labs/bypass`
> allows to create a mock HTTP server that test code
> can access during tests without resorting to dynamic
> mocking techniques that introduce global changes
> and complicate the testing stack

## Adding Tests to Channels

* Remember Channels are also OTP servers
* Phoenix includes the `Phoenix.ChannelTest` module
    * can make several types of common assertions, ie.
        * application pushes messages to a client
        * replies to a message
        * sends broadcasts
* `test/support/channel_case.ex` is generated by `mix`

```
defmodule Rumbl.ChannelCase do

  #
  # Establish that it is a test case
  #
  use ExUnit.CaseTemplate

  #
  # Specify the template for the code that
  # you want to inject
  using do
    quote do
    
      #
      # Establish the foundation
      #
      # Import conveniences for testing with channels
      use Phoenix.ChannelTest


      #
      # Few other imports
      #
      alias Rumbl.Repo
      import Ecto
      import Ecto.Changeset
      import Ecto.Query


      # The default endpoint for testing
      @endpoint Rumbl.Endpoint
    end
  end

  setup tags do
    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Rumbl.Repo)

    unless tags[:async] do
      Ecto.Adapters.SQL.Sandbox.mode(Rumbl.Repo, {:shared, self()})
    end

    :ok
  end
end

```

## Communicating with a Test Channel

* Test process works as a **client** of the channel
    * then we are able to establish a test connection using `subscribe_and_join`
    * same way the browser is a channel client

### Wrapping

* We tested our OTP layer for our `InfoSys` OTP Application
* We built a specific backend rather than a dynamic stub or mock to keep our tests isolated
* We tested our sockets authentication code
* We used the Phoenix testing support to test our channels

* Didn't cover user acceptance/performance testing